import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
from torch.utils.data import DataLoader, Dataset
from pytorch_lightning.metrics import Metric
from pytorch_lightning.metrics.functional.classification import stat_scores_multiple_classes
from pytorch_lightning.metrics.functional.reduction import reduce

# Utility Functions
def calculate_3d_occupancy_grid_parameters(x_bounds, y_bounds, z_bounds):
    bev_resolution = torch.tensor([row[2] for row in [x_bounds, y_bounds, z_bounds]])
    bev_start_position = torch.tensor([row[0] + row[2] / 2.0 for row in [x_bounds, y_bounds, z_bounds]])
    bev_dimension = torch.tensor([(row[1] - row[0]) / row[2] for row in [x_bounds, y_bounds, z_bounds]], dtype=torch.long)
    return bev_resolution, bev_start_position, bev_dimension

# Model Definition
class Occupancy3DPredictor(nn.Module):
    def __init__(self, input_channels, output_channels):
        super(Occupancy3DPredictor, self).__init__()
        self.conv1 = nn.Conv3d(input_channels, 64, kernel_size=3, stride=1, padding=1)
        self.conv2 = nn.Conv3d(64, 128, kernel_size=3, stride=1, padding=1)
        self.conv3 = nn.Conv3d(128, 256, kernel_size=3, stride=1, padding=1)
        self.conv4 = nn.Conv3d(256, output_channels, kernel_size=3, stride=1, padding=1)
        self.relu = nn.ReLU()
        self.softmax = nn.Softmax(dim=1)

    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.relu(self.conv2(x))
        x = self.relu(self.conv3(x))
        x = self.softmax(self.conv4(x))
        return x

def predict_3d_occupancy(input_tensor, model):
    model.eval()
    with torch.no_grad():
        occupancy_grid = model(input_tensor)
    return occupancy_grid

# Metric for 3D IoU
class IntersectionOverUnion3D(Metric):
    def __init__(self, n_classes, ignore_index=None, absent_score=0.0, reduction='none', compute_on_step=False):
        super().__init__(compute_on_step=compute_on_step)
        self.n_classes = n_classes
        self.ignore_index = ignore_index
        self.absent_score = absent_score
        self.reduction = reduction
        self.add_state('true_positive', default=torch.zeros(n_classes), dist_reduce_fx='sum')
        self.add_state('false_positive', default=torch.zeros(n_classes), dist_reduce_fx='sum')
        self.add_state('false_negative', default=torch.zeros(n_classes), dist_reduce_fx='sum')
        self.add_state('support', default=torch.zeros(n_classes), dist_reduce_fx='sum')

    def update(self, prediction, target):
        tps, fps, _, fns, sups = stat_scores_multiple_classes(prediction, target, self.n_classes)
        self.true_positive += tps
        self.false_positive += fps
        self.false_negative += fns
        self.support += sups

    def compute(self):
        scores = torch.zeros(self.n_classes, device=self.true_positive.device, dtype=torch.float32)
        for class_idx in range(self.n_classes):
            if class_idx == self.ignore_index:
                continue
            tp = self.true_positive[class_idx]
            fp = self.false_positive[class_idx]
            fn = self.false_negative[class_idx]
            sup = self.support[class_idx]
            if sup + tp + fp == 0:
                scores[class_idx] = self.absent_score
                continue
            denominator = tp + fp + fn
            score = tp.to(torch.float) / denominator
            scores[class_idx] = score
        if (self.ignore_index is not None) and (0 <= self.ignore_index < self.n_classes):
            scores = torch.cat([scores[:self.ignore_index], scores[self.ignore_index+1:]])
        return reduce(scores, reduction=self.reduction)

# Training and Evaluation Functions
def train_3d_occupancy_model(model, dataloader, optimizer, criterion, num_epochs):
    model.train()
    for epoch in range(num_epochs):
        for batch in dataloader:
            inputs, targets = batch
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
        print(f'Epoch {epoch + 1}/{num_epochs}, Loss: {loss.item()}')

def evaluate_3d_occupancy_model(model, dataloader, metric):
    model.eval()
    metric.reset()
    with torch.no_grad():
        for batch in dataloader:
            inputs, targets = batch
            outputs = model(inputs)
            metric.update(outputs, targets)
    return metric.compute()

# Data Preparation
def create_voxel_grid(point_cloud, voxel_size, grid_size, grid_center):
    nx, ny, nz = grid_size
    cx, cy, cz = grid_center
    voxel_grid = np.zeros(grid_size, dtype=np.float32)
    voxel_indices = np.floor((point_cloud - np.array([cx, cy, cz])) / voxel_size).astype(int)
    valid_mask = (
        (voxel_indices[:, 0] >= 0) & (voxel_indices[:, 0] < nx) &
        (voxel_indices[:, 1] >= 0) & (voxel_indices[:, 1] < ny) &
        (voxel_indices[:, 2] >= 0) & (voxel_indices[:, 2] < nz)
    )
    voxel_indices = voxel_indices[valid_mask]
    voxel_grid[voxel_indices[:, 0], voxel_indices[:, 1], voxel_indices[:, 2]] = 1.0
    return torch.tensor(voxel_grid)

class PointCloudDataset(Dataset):
    def __init__(self, point_cloud_files, voxel_size, grid_size, grid_center):
        self.point_cloud_files = point_cloud_files
        self.voxel_size = voxel_size
        self.grid_size = grid_size
        self.grid_center = grid_center

    def __len__(self):
        return len(self.point_cloud_files)

    def __getitem__(self, idx):
        point_cloud = np.load(self.point_cloud_files[idx])
        voxel_grid = create_voxel_grid(point_cloud, self.voxel_size, self.grid_size, self.grid_center)
        return voxel_grid, voxel_grid  # Using voxel grid as both input and target for demonstration

# Main Script
x_bounds = [0, 50, 1]
y_bounds = [-25, 25, 1]
z_bounds = [-3, 3, 1]
bev_resolution, bev_start_position, bev_dimension = calculate_3d_occupancy_grid_parameters(x_bounds, y_bounds, z_bounds)
input_channels = 1
output_channels = 2
model = Occupancy3DPredictor(input_channels, output_channels)
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
metric = IntersectionOverUnion3D(n_classes=2)

train_point_cloud_files = ['#路径还未增加']
val_point_cloud_files = ['#路径还未增加']
voxel_size = 0.1
grid_size = (100, 100, 100)
grid_center = (5, 5, 5)

train_dataset = PointCloudDataset(train_point_cloud_files, voxel_size, grid_size, grid_center)
val_dataset = PointCloudDataset(val_point_cloud_files, voxel_size, grid_size, grid_center)
train_dataloader = DataLoader(train_dataset, batch_size=4, shuffle=True, num_workers=4)
val_dataloader = DataLoader(val_dataset, batch_size=4, shuffle=False, num_workers=4)

num_epochs = 10
train_3d_occupancy_model(model, train_dataloader, optimizer, criterion, num_epochs)
iou_scores = evaluate_3d_occupancy_model(model, val_dataloader, metric)
print(f'3D IoU scores: {iou_scores}')
